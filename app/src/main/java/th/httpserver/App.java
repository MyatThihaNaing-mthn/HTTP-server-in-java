/*
 * This source file was generated by the Gradle 'init' task
 */
package th.httpserver;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.net.ssl.SSLContext;

import th.httpserver.http.HttpParser;
import th.httpserver.http.HttpRequest;
import th.httpserver.http.HttpResponse;
import th.httpserver.middlwares.AuthMiddleware;
import th.httpserver.middlwares.Middleware;
import th.httpserver.middlwares.MiddlewareChain;
import th.httpserver.middlwares.ResponseSender;
import th.httpserver.middlwares.StaticFilesMiddleware;
import th.httpserver.tls.TLSServer;
import th.httpserver.Routes.Router;

public class App {
    private static final int HTTPS_PORT = 4221;
    private static final int HTTP_PORT = 4220;
    private static String ROOT_DIR = ".";
    private static final int THREAD_POOL_SIZE = 10;
    private static final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_POOL_SIZE);   
    private static final List<Middleware> middlewares = new ArrayList<>();

    public static void main(String[] args) {
        setRootDir(args);
        middlewares.add(new AuthMiddleware());
        middlewares.add(new StaticFilesMiddleware());
        try {
            // Initialize router
            Router.getInstance();

            SSLContext sslContext = TLSServer.createSSLContext();
            startServer(sslContext);
        } catch (Exception e) {
            System.err.println("Server failed to start: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void setRootDir(String[] args) {
        if (args.length > 0) {
            List<String> argsList = Arrays.asList(args);
            if (argsList.contains("--directory")) {
                if (argsList.indexOf("--directory") + 1 < argsList.size()) {
                    ROOT_DIR = argsList.get(argsList.indexOf("--directory") + 1);
                }
            }
        }
        System.out.println("ROOT_DIR: " + ROOT_DIR);
    }

    public static String getRootDir() {
        return ROOT_DIR;
    }

    private static void handleClientConnection(Socket clientSocket) {

        threadPool.execute(() -> {
        boolean isKeepAlive = true;
        while (isKeepAlive) {
            
            try {
                HttpRequest httpRequest = HttpParser.parse(clientSocket.getInputStream());
                if (httpRequest == null) {
                System.out.println("Invalid request");
                return;
            }
            if(httpRequest.getHeader("Connection") != null) {
                isKeepAlive = httpRequest.getHeader("Connection").equals("keep-alive");
            }
            HttpResponse httpResponse = new HttpResponse();
            MiddlewareChain middlewareChain = new MiddlewareChain(middlewares);
            middlewareChain.handle(httpRequest, httpResponse);

            ResponseSender.sendResponse(httpResponse, clientSocket);
                        
        } catch (IOException e) {
            e.printStackTrace();
            } finally {
                System.out.println("isKeepAlive: " + isKeepAlive);
                if(!isKeepAlive ) {
                    closeSocketQuietly(clientSocket);
                }
            }
        }});         
    }

    private static void startServer(SSLContext sslContext) throws IOException {
        try (ServerSocket serverSocket = createServerSocket(sslContext)) {
            serverSocket.setReuseAddress(true);
            System.out.println("Server is running on port " + (sslContext != null ? HTTPS_PORT : HTTP_PORT));
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("Accepted new connection");
                handleClientConnection(clientSocket);
            }
        }
    }

    private static ServerSocket createServerSocket(SSLContext sslContext) throws IOException {
        if (sslContext != null) {
            return sslContext.getServerSocketFactory().createServerSocket(HTTPS_PORT);
        }
        return new ServerSocket(HTTP_PORT);
    }

    private static void closeSocketQuietly(Socket socket) {
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
