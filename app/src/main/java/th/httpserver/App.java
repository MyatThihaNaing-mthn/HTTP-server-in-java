/*
 * This source file was generated by the Gradle 'init' task
 */
package th.httpserver;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.net.ssl.SSLContext;
import th.httpserver.http.HttpResponse;
import th.httpserver.http.RequestContext;
import th.httpserver.middlwares.AuthMiddleware;
import th.httpserver.middlwares.Middleware;
import th.httpserver.middlwares.MiddlewareChain;
import th.httpserver.middlwares.ParseMiddleware;
import th.httpserver.middlwares.ResponseSender;
import th.httpserver.middlwares.StaticFilesMiddleware;
import th.httpserver.middlwares.ratelimiter.RateLimiterMiddleware;
import th.httpserver.tls.TLSServer;
import th.httpserver.Routes.Router;

public class App {
    private static final int HTTPS_PORT = 4221;
    private static final int HTTP_PORT = 4220;
    private static String ROOT_DIR = ".";
    private static final int THREAD_POOL_SIZE = 10;
    private static final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_POOL_SIZE);
    private static final List<Middleware> middlewares = new ArrayList<>();

    public static void main(String[] args) {
        setRootDir(args);
        middlewares.add(new RateLimiterMiddleware());
        middlewares.add(new AuthMiddleware());
        middlewares.add(new StaticFilesMiddleware());
        try {
            // Initialize router
            Router.getInstance();

            SSLContext sslContext = TLSServer.createSSLContext();
            startServer(sslContext);
        } catch (Exception e) {
            System.err.println("Server failed to start: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    private static void setRootDir(String[] args) {
        if (args.length > 0) {
            List<String> argsList = Arrays.asList(args);
            if (argsList.contains("--directory")) {
                if (argsList.indexOf("--directory") + 1 < argsList.size()) {
                    ROOT_DIR = argsList.get(argsList.indexOf("--directory") + 1);
                }
            }
        }
        System.out.println("ROOT_DIR: " + ROOT_DIR);
    }

    public static String getRootDir() {
        return ROOT_DIR;
    }

    private static void handleClientConnection(Socket clientSocket) {
        threadPool.execute(() -> {
            boolean isKeepAlive = true;
            RequestContext ctx = new RequestContext(clientSocket);
            HttpResponse response = new HttpResponse();
            while (isKeepAlive) {
                try {
                    // Create a new middleware chain for each request with ParseMiddleware
                    List<Middleware> requestMiddlewares = new ArrayList<>();
                    requestMiddlewares.add(new ParseMiddleware(clientSocket));
                    requestMiddlewares.addAll(middlewares);
                    MiddlewareChain middlewareChain = new MiddlewareChain(requestMiddlewares);
                    
                    middlewareChain.handle(ctx, response);
                    if (ctx.getRequest() == null) {
                        System.out.println("Invalid request");
                        return;
                    }
                    if (ctx.getRequest().getHeader("Connection") != null) {
                        isKeepAlive = ctx.getRequest().getHeader("Connection").equals("keep-alive");
                    }
                    ResponseSender.sendResponse(response, clientSocket);

                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    System.out.println("isKeepAlive: " + isKeepAlive);
                    if (!isKeepAlive) {
                        closeSocketQuietly(clientSocket);
                    }
                }
            }
        });
    }

    private static void startServer(SSLContext sslContext) throws IOException {
        try (ServerSocket serverSocket = createServerSocket(sslContext)) {
            serverSocket.setReuseAddress(true);
            System.out.println("Server is running on port " + (sslContext != null ? HTTPS_PORT : HTTP_PORT));
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("Accepted new connection");
                handleClientConnection(clientSocket);
            }
        }
    }

    private static ServerSocket createServerSocket(SSLContext sslContext) throws IOException {
        if (sslContext != null) {
            return sslContext.getServerSocketFactory().createServerSocket(HTTPS_PORT);
        }
        return new ServerSocket(HTTP_PORT);
    }

    private static void closeSocketQuietly(Socket socket) {
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
